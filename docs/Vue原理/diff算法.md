# diff 算法

- 在新旧 vnode 节点比较时，为了以最小的性能开销完成更新操作就需要用到diff算法

- vue2中使用的是双端diff算法

- vue3中使用的是快速diff算法


### 简单diff算法

> 一、找可复用的DOM

- 新旧虚拟节点对比时，如果两个虚拟节点的 type 属性和 key 属性值都相等的话，那就认为他们是相同的，可以进行 Dom 的复用；

> 二、打补丁（更新节点内容，利用patch）

- 但是需要注意的是：DOM可以复用并不代表节点不需要更新，因为有可能子节点的文本内容不一样，所以需要对新旧虚拟节点进行打补丁。

> 三、找需要移动的节点

- 取新的一组节点的第一个节点的key，去旧节点中寻找相同的key，如果能找到，并且索引值递增的顺序被打破，那这个节点对应的真实DOM就要移动

- 举个例子： 

    - 旧节点： p-1 p-2 p-3  索引：  0 1 2
    - 新节点： p-3 p-1 p-2  索引：  1 2 0

- 可以看到索引值的递增顺序被打破了。所以 p-1 和 p-2 节点对应的真实DOM都要移动到 p-3 的后面

### 双端diff算法

- 因为简单的diff有缺陷，比如以上的例子中，需要移动两次DOM节点，而双端只需要移动一次就行，所以说双端diff做了减少dom的移动次数的优化

> 找可复用的DOM

- 定义四个索引，新旧两组节点的`开始索引`，`结束索引`
- 步骤：
    - 新开始和旧开始比较，key相同就复用，否则什么都不做
    - 新结尾和旧结尾比较，key相同就复用，否则什么都不做
    - 新结尾和旧开始比较，key相同就复用，否则什么都不做
    - 新开始和旧结尾比较，key相同就复用，否则什么都不做

> 更新内容（打补丁），移动元素

- 可复用的节点找到之后需要调用patch函数进行打补丁，然后移动元素

- 新旧节点的索引都是从两边向中间靠拢，当头部索引大于尾部索引就完成了更新

> 挂载新节点和卸载旧节点

- 如果找不到可复用的节点，那就会进行挂载新增节点和卸载旧节点的操作

> 非理想状态

- 当头尾节点都找不到复用的情况下，就会拿新节点的头部节点去旧节点中寻找，找到就复用


### 快速diff算法

> 预处理

- 先`从前往后`遍历找到全部相同的`前置节点`
- 然后`从后往前`找到全部相同的`后置节点`

> 找最长递增子序列

- 用一个source数组保存新节点在旧节点中的位置
- 求出source数组的最长递增子序列
- 最长递增子序列所对应的节点就是不需要移动的节点

## 总结

- 三种diff算法都遵循同样的处理规则：
    - 找到可复用的节点，打补丁，以及找到节点移动的位置
    - 找出那些需要被添加删除节点

- 只不过是在这些寻找的过程做了不同的优化而已