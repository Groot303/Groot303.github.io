import{_ as i,c as n,a as e,b as l,t as h,e as r,w as a,d as o,r as u,o as d}from"./app.8f7889f4.js";const G=JSON.parse('{"title":"vue-router基础知识","description":"","frontmatter":{"title":"vue-router基础知识","categories":["Vue-router"],"tags":["vue-router"]},"headers":[{"level":2,"title":"全局路由钩子","slug":"全局路由钩子","link":"#全局路由钩子","children":[]},{"level":2,"title":"单个路由独享钩子","slug":"单个路由独享钩子","link":"#单个路由独享钩子","children":[]},{"level":2,"title":"组件内的钩子","slug":"组件内的钩子","link":"#组件内的钩子","children":[]},{"level":2,"title":"完整的导航解析流程（假设是从a组件离开，第一次进入b组件）","slug":"完整的导航解析流程-假设是从a组件离开-第一次进入b组件","link":"#完整的导航解析流程-假设是从a组件离开-第一次进入b组件","children":[]},{"level":2,"title":"hash/history区别","slug":"hash-history区别","link":"#hash-history区别","children":[]},{"level":2,"title":"hash和query的位置","slug":"hash和query的位置","link":"#hash和query的位置","children":[]},{"level":2,"title":"params和query的区别","slug":"params和query的区别","link":"#params和query的区别","children":[]},{"level":2,"title":"如何获取页面的hash变化","slug":"如何获取页面的hash变化","link":"#如何获取页面的hash变化","children":[]}],"relativePath":"Vue核心插件/vue-router基础.md"}'),_={name:"Vue核心插件/vue-router基础.md"},c={id:"frontmatter-title",tabindex:"-1"},f=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),p=e("h2",{id:"全局路由钩子",tabindex:"-1"},[l("全局路由钩子 "),e("a",{class:"header-anchor",href:"#全局路由钩子","aria-hidden":"true"},"#")],-1),b=e("li",null,"router.beforeResolve 全局解析守卫，在 beforeRouteEnter 之后调用",-1),g=e("li",null,"router.afterEach 全局后置钩子，进入路由之后",-1),m=o('<h2 id="单个路由独享钩子" tabindex="-1">单个路由独享钩子 <a class="header-anchor" href="#单个路由独享钩子" aria-hidden="true">#</a></h2><ul><li>router.beforeEnter()</li></ul><h2 id="组件内的钩子" tabindex="-1">组件内的钩子 <a class="header-anchor" href="#组件内的钩子" aria-hidden="true">#</a></h2><ul><li>beforeRouteUpdate、</li><li>beforeRouteEnter：路由组件的组件进入路由前钩子</li><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开</li></ul><h2 id="完整的导航解析流程-假设是从a组件离开-第一次进入b组件" tabindex="-1">完整的导航解析流程（假设是从a组件离开，第一次进入b组件） <a class="header-anchor" href="#完整的导航解析流程-假设是从a组件离开-第一次进入b组件" aria-hidden="true">#</a></h2>',5),y=e("li",null,"导航被触发。",-1),v=e("strong",null,"beforeRouteLeave",-1),q=e("strong",null,"全局的beforeEach",-1),x=e("strong",null,"beforeRouteUpdate",-1),E=e("strong",null,"beforeEnter",-1),R=e("li",null,"解析异步路由组件。",-1),T=e("strong",null,"beforeRouteEnter",-1),k=e("strong",null,"beforeResolve",-1),V=e("li",null,"导航被确认。",-1),S=e("strong",null,"afterEach",-1),$=e("strong",null,"beforeCreate",-1),w=e("strong",null,"created",-1),C=e("strong",null,"beforeMount",-1),N=e("strong",null,"deactivated",-1),A=e("strong",null,"mounted",-1),D=e("strong",null,"activated",-1),P={start:"11"},I=e("li",null,"触发 DOM 更新",-1),B=e("strong",null,"beforeRouteEnter",-1),L=o('<h2 id="hash-history区别" tabindex="-1">hash/history区别 <a class="header-anchor" href="#hash-history区别" aria-hidden="true">#</a></h2><ol><li>hash</li></ol><ul><li>有#，hash值出现在url中，但是不会出现在http请求中，所以改变hash值不会重新加载页面，兼容性好</li><li>hash符号之前的url会被包含在请求中，后端没有做到对路由的全覆盖也不会出现404</li><li>主要原理是onhashchange事件</li></ul><ol start="2"><li>history</li></ol><ul><li>无#，前端的url必须和发送http请求的url一致才行。如果没有相应的路由和资源就会出现404</li><li>pushState() 和 replaceState() 可以做到改变url但又不刷新页面的效果。</li></ul><h2 id="hash和query的位置" tabindex="-1">hash和query的位置 <a class="header-anchor" href="#hash和query的位置" aria-hidden="true">#</a></h2><ul><li>hash在query的后面 <ul><li>?search=a这种叫query，#hash叫fragment。</li><li>query的规定是以第一个?开始，至行尾或#结束。</li><li>fragment以#为开始，行尾为结束。</li></ul></li></ul><h2 id="params和query的区别" tabindex="-1">params和query的区别 <a class="header-anchor" href="#params和query的区别" aria-hidden="true">#</a></h2><ul><li>用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 <a href="http://this.$route.query.name" target="_blank" rel="noreferrer">this.$route.query.name</a> 和 <a href="http://this.$route.params.name" target="_blank" rel="noreferrer">this.$route.params.name</a> 。</li><li>url地址显示：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</li><li>注意：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据</li></ul><h2 id="如何获取页面的hash变化" tabindex="-1">如何获取页面的hash变化 <a class="header-anchor" href="#如何获取页面的hash变化" aria-hidden="true">#</a></h2><ul><li>用watch监听$route的变化</li><li>window.location.hash读取#值 window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录 Vue-router跳转和location.href有什么区别</li></ul>',11);function M(s,O,U,j,J,z){const t=u("font");return d(),n("div",null,[e("h1",c,[l(h(s.$frontmatter.title)+" ",1),f]),p,e("ul",null,[e("li",null,[l("router.beforeEach 全局前置守卫，进入路由之前，"),r(t,{color:"red"},{default:a(()=>[l(" 可用于登录验证、全局路由loading 、路由拦截")]),_:1}),l("等")]),b,g]),m,e("ol",null,[y,e("li",null,[l("在失活的组件里调用 "),r(t,{color:"red"},{default:a(()=>[v]),_:1}),l(" 守卫。")]),e("li",null,[l("调用 "),r(t,{color:"red"},{default:a(()=>[q]),_:1}),l(" 守卫。")]),e("li",null,[l("在重用的组件里调用 "),r(t,{color:"red"},{default:a(()=>[x]),_:1}),l(" 守卫(2.2+)。")]),e("li",null,[l("在路由配置里调用 "),r(t,{color:"red"},{default:a(()=>[E]),_:1}),l("。")]),R,e("li",null,[l("在被激活的组件里调用 "),r(t,{color:"red"},{default:a(()=>[T]),_:1}),l("。")]),e("li",null,[l("调用全局的"),r(t,{color:"red"},{default:a(()=>[k]),_:1}),l(" 守卫(2.5+)。")]),V,e("li",null,[l("调用全局的 "),r(t,{color:"red"},{default:a(()=>[S]),_:1}),l(" 钩子。")])]),e("p",null,[l("💥 "),r(t,{color:"purple"},{default:a(()=>[$]),_:1})]),e("p",null,[l("💥 "),r(t,{color:"purple"},{default:a(()=>[w]),_:1})]),e("p",null,[l("💥 "),r(t,{color:"purple"},{default:a(()=>[C]),_:1})]),e("p",null,[l("💥 "),r(t,{color:"purple"},{default:a(()=>[N]),_:1}),l("：离开缓存组件a，或者触发a的 beforeDestroy 和 destroyed 组件销毁钩子")]),e("p",null,[l("💥 "),r(t,{color:"purple"},{default:a(()=>[A]),_:1})]),e("p",null,[l("💥 "),r(t,{color:"purple"},{default:a(()=>[D]),_:1})]),e("ol",P,[I,e("li",null,[l("调用"),r(t,{color:"red"},{default:a(()=>[B]),_:1}),l(" 中 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。")])]),L])}const H=i(_,[["render",M]]);export{G as __pageData,H as default};
