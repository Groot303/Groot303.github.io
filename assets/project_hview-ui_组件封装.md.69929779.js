import{_ as l,c as e,o as i,d as a}from"./app.77446003.js";const f=JSON.parse('{"title":"关于组件封装的技巧","description":"","frontmatter":{},"headers":[{"level":2,"title":"便捷性性和可扩展性","slug":"便捷性性和可扩展性","link":"#便捷性性和可扩展性","children":[]},{"level":2,"title":"一、样式编写","slug":"一、样式编写","link":"#一、样式编写","children":[]},{"level":2,"title":"二、组件结构","slug":"二、组件结构","link":"#二、组件结构","children":[]},{"level":2,"title":"三、组件行为","slug":"三、组件行为","link":"#三、组件行为","children":[]},{"level":2,"title":"四、props","slug":"四、props","link":"#四、props","children":[]}],"relativePath":"project/hview-ui/组件封装.md"}'),r={name:"project/hview-ui/组件封装.md"},t=a('<h1 id="关于组件封装的技巧" tabindex="-1">关于组件封装的技巧 <a class="header-anchor" href="#关于组件封装的技巧" aria-hidden="true">#</a></h1><h2 id="便捷性性和可扩展性" tabindex="-1">便捷性性和可扩展性 <a class="header-anchor" href="#便捷性性和可扩展性" aria-hidden="true">#</a></h2><ul><li>组件的封装其实是一个易用性和可扩展性的权衡 <ul><li>封装得越多，组件便捷性就越高，可扩展性就越低</li><li>封装得越少，组件的可扩展性就越高，相对的，便捷性就越低</li></ul></li><li>所以要根据使用的场景来控制组件的封装粒度</li></ul><h2 id="一、样式编写" tabindex="-1">一、样式编写 <a class="header-anchor" href="#一、样式编写" aria-hidden="true">#</a></h2><ul><li>尽量使用低权值</li><li>定义一些内置类名（比如组件大小的定义，可以有小，中，大的内置类名）</li></ul><h2 id="二、组件结构" tabindex="-1">二、组件结构 <a class="header-anchor" href="#二、组件结构" aria-hidden="true">#</a></h2><ul><li>内容是固定就写死，不确定部分就使用slot</li><li>定义一些 slot 和 默认slot，用户传入 slot 就用传入的，否则使用默认 slot （便捷性和可扩展性）</li></ul><h4 id="举个栗子" tabindex="-1">举个栗子 <a class="header-anchor" href="#举个栗子" aria-hidden="true">#</a></h4><ul><li><p>比如一个弹窗组件，确定取消，关闭按钮大多数情况之下是固定的，头部标题发多数情况需要改变，那就可以的判断用户有没有传入 slot ，如果有那就用传进来的，如果没有那就用默认的</p></li><li><p>再者，子组件的一些数据可以作为 slot 上的一个属性传递给父组件，这样有时候一些数据就不用使用事件那么麻烦来传了</p></li></ul><h2 id="三、组件行为" tabindex="-1">三、组件行为 <a class="header-anchor" href="#三、组件行为" aria-hidden="true">#</a></h2><ul><li>把组件的行为分为基本行为和业务行为，每个行为都给父组件一个监听事件</li><li>为了更好的扩展可以拆分某个行为的前中后等生命周期</li></ul><h4 id="举个栗子-1" tabindex="-1">举个栗子 <a class="header-anchor" href="#举个栗子-1" aria-hidden="true">#</a></h4><ul><li>比如一个弹窗组件，确定取消，关闭按钮都是用来关闭组件弹窗的，那这种行为就可以直接写在组件内部；而弹窗关闭之后的所要做的事情就应该交给父组件去做（给父组件一个监听事件）。</li><li>定义前中后生命周期，弹窗前需要做什么，弹窗后的事件等等，增加组件的可扩展性</li></ul><h2 id="四、props" tabindex="-1">四、props <a class="header-anchor" href="#四、props" aria-hidden="true">#</a></h2><ul><li>组件本身行为相关的数据内部定义，业务相关的数据由父组件传入</li><li>组件本身尽可能少写 data</li><li>props 也可以增强组件的可扩展性（比如可以传入一个布尔值来控制一个元素是否显示）</li></ul>',15),h=[t];function d(s,n,o,c,u,p){return i(),e("div",null,h)}const x=l(r,[["render",d]]);export{f as __pageData,x as default};
