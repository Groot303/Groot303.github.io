import{_ as e,c as i,o as t,d as l}from"./app.391ae89b.js";const f=JSON.parse('{"title":"TypeScript知识总结","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是 ts？","slug":"什么是-ts","link":"#什么是-ts","children":[]},{"level":2,"title":"ts 和 js 的区别是什么？","slug":"ts-和-js-的区别是什么","link":"#ts-和-js-的区别是什么","children":[]},{"level":2,"title":"TypeScript 中 ?.   ??   !   !.   _ 等符号的含义？","slug":"typescript-中-等符号的含义","link":"#typescript-中-等符号的含义","children":[]},{"level":2,"title":"TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？","slug":"typescript-中-const-和-readonly-的区别-枚举和常量枚举的区别-接口和类型别名的区别","link":"#typescript-中-const-和-readonly-的区别-枚举和常量枚举的区别-接口和类型别名的区别","children":[]},{"level":2,"title":"TypeScript 中 any 类型的作用是什么？","slug":"typescript-中-any-类型的作用是什么","link":"#typescript-中-any-类型的作用是什么","children":[]},{"level":2,"title":"TypeScript 中 any、never、unknown、null & undefined 和 void 有什么区别？","slug":"typescript-中-any、never、unknown、null-undefined-和-void-有什么区别","link":"#typescript-中-any、never、unknown、null-undefined-和-void-有什么区别","children":[]},{"level":2,"title":"TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？","slug":"typescript-中的-this-和-javascript-中的-this-有什么差异","link":"#typescript-中的-this-和-javascript-中的-this-有什么差异","children":[]},{"level":2,"title":"TypeScript 中使用 Union Types 时有哪些注意事项？","slug":"typescript-中使用-union-types-时有哪些注意事项","link":"#typescript-中使用-union-types-时有哪些注意事项","children":[]},{"level":2,"title":"TypeScript 中 type 和 interface 的区别?","slug":"typescript-中-type-和-interface-的区别","link":"#typescript-中-type-和-interface-的区别","children":[]},{"level":2,"title":"TypeScript 模块的加载机制","slug":"typescript-模块的加载机制","link":"#typescript-模块的加载机制","children":[]},{"level":2,"title":"对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？","slug":"对-typescript-类中成员的-public、private、protected、readonly-修饰符的理解","link":"#对-typescript-类中成员的-public、private、protected、readonly-修饰符的理解","children":[]},{"level":2,"title":"keyof 和 typeof 关键字的作用？","slug":"keyof-和-typeof-关键字的作用","link":"#keyof-和-typeof-关键字的作用","children":[]}],"relativePath":"TypeScript/知识总结.md"}'),n={name:"TypeScript/知识总结.md"},r=l('<h1 id="typescript知识总结" tabindex="-1">TypeScript知识总结 <a class="header-anchor" href="#typescript知识总结" aria-hidden="true">#</a></h1><h2 id="什么是-ts" tabindex="-1">什么是 ts？ <a class="header-anchor" href="#什么是-ts" aria-hidden="true">#</a></h2><ul><li>ts 是一个强类型的 js 超集，支持 es6 语法，支持面向对象编程，如类、接口、继承、泛型等，ts 不能在浏览器上运行，需要编译成 js 来运行</li></ul><h2 id="ts-和-js-的区别是什么" tabindex="-1">ts 和 js 的区别是什么？ <a class="header-anchor" href="#ts-和-js-的区别是什么" aria-hidden="true">#</a></h2><ul><li>ts 可以在开发编译时就会发现错误，js 需要运行才会暴露</li><li>ts 是一个强类型语言，代码可读性强，利于项目的维护</li></ul><h2 id="typescript-中-等符号的含义" tabindex="-1">TypeScript 中 ?. ?? ! !. _ 等符号的含义？ <a class="header-anchor" href="#typescript-中-等符号的含义" aria-hidden="true">#</a></h2><ul><li>?. 可选链： 遇到 null 和 undefined 可以立即停止表达式的运行。</li><li>?? 空值合并运算符：当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。</li><li>! 非空断言运算符： x! 将从 x 值域中排除 null 和 undefined</li><li>!. 在变量名后添加：可以断言排除undefined和null类型</li><li>_ 数字分割符：分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324。</li></ul><h2 id="typescript-中-const-和-readonly-的区别-枚举和常量枚举的区别-接口和类型别名的区别" tabindex="-1">TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？ <a class="header-anchor" href="#typescript-中-const-和-readonly-的区别-枚举和常量枚举的区别-接口和类型别名的区别" aria-hidden="true">#</a></h2><ul><li>const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。</li><li>枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</li><li>接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</li></ul><h2 id="typescript-中-any-类型的作用是什么" tabindex="-1">TypeScript 中 any 类型的作用是什么？ <a class="header-anchor" href="#typescript-中-any-类型的作用是什么" aria-hidden="true">#</a></h2><ul><li>为编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。</li></ul><h2 id="typescript-中-any、never、unknown、null-undefined-和-void-有什么区别" tabindex="-1">TypeScript 中 any、never、unknown、null &amp; undefined 和 void 有什么区别？ <a class="header-anchor" href="#typescript-中-any、never、unknown、null-undefined-和-void-有什么区别" aria-hidden="true">#</a></h2><ul><li>any: 动态的变量类型（失去了类型检查的作用）。</li><li>never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</li><li>unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型。</li><li>null &amp; undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。</li><li>void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void。</li></ul><h2 id="typescript-中的-this-和-javascript-中的-this-有什么差异" tabindex="-1">TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？ <a class="header-anchor" href="#typescript-中的-this-和-javascript-中的-this-有什么差异" aria-hidden="true">#</a></h2><ol><li>TypeScript：noImplicitThis: true 的情况下，必须去声明 this 的类型，才能在函数或者对象中使用this。</li><li>Typescript 中箭头函数的 this 和 ES6 中箭头函数中的 this 是一致的。</li></ol><h2 id="typescript-中使用-union-types-时有哪些注意事项" tabindex="-1">TypeScript 中使用 Union Types 时有哪些注意事项？ <a class="header-anchor" href="#typescript-中使用-union-types-时有哪些注意事项" aria-hidden="true">#</a></h2><ul><li>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法。 function getLength(something: string | number): number { return something.length; } //Property &#39;length&#39; does not exist on type &#39;number&#39;.</li></ul><h2 id="typescript-中-type-和-interface-的区别" tabindex="-1">TypeScript 中 type 和 interface 的区别? <a class="header-anchor" href="#typescript-中-type-和-interface-的区别" aria-hidden="true">#</a></h2><ul><li>相同点： a. 都可以描述 &#39;对象&#39; 或者 &#39;函数&#39; b. 都允许拓展(extends)</li><li>不同点： c. type 可以声明基本类型，联合类型，元组 d. type 可以使用 typeof 获取实例的类型进行赋值 e. 多个相同的 interface 声明可以自动合并 使用 interface 描述‘数据结构’，使用 type 描述‘类型关系’</li></ul><h2 id="typescript-模块的加载机制" tabindex="-1">TypeScript 模块的加载机制 <a class="header-anchor" href="#typescript-模块的加载机制" aria-hidden="true">#</a></h2><p>假设有一个导入语句 import { a } from &quot;moduleA&quot;;</p><ul><li>首先，编译器会尝试定位需要导入的模块文件，通过绝对或者相对的路径查找方式；</li><li>如果上面的解析失败了，没有查找到对应的模块，编译器会尝试定位一个外部模块声明（.d.ts）；</li><li>最后，如果编译器还是不能解析这个模块，则会抛出一个错误 error TS2307: Cannot find module &#39;moduleA&#39;.</li></ul><h2 id="对-typescript-类中成员的-public、private、protected、readonly-修饰符的理解" tabindex="-1">对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？ <a class="header-anchor" href="#对-typescript-类中成员的-public、private、protected、readonly-修饰符的理解" aria-hidden="true">#</a></h2><ul><li>public：成员都默认为public，被此限定符修饰的成员是可以被外部访问；</li><li>private：被此限定符修饰的成员是只可以被类的内部访问；</li><li>protected： 被此限定符修饰的成员是只可以被类的内部以及类的子类访问;</li><li>readonly：关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</li></ul><h2 id="keyof-和-typeof-关键字的作用" tabindex="-1">keyof 和 typeof 关键字的作用？ <a class="header-anchor" href="#keyof-和-typeof-关键字的作用" aria-hidden="true">#</a></h2><ul><li>keyof 索引类型查询操作符： 获取索引类型的属性名，构成联合类型</li><li>typeof： 获取一个变量或对象的类型。</li></ul>',26),p=[r];function a(s,c,d,o,y,h){return t(),i("div",null,p)}const v=e(n,[["render",a]]);export{f as __pageData,v as default};
