import{_ as t,c as l,o as i,d as a}from"./app.f1dc7af0.js";const e="/https通信.jpg",f=JSON.parse('{"title":"https知识总结","description":"","frontmatter":{},"headers":[{"level":2,"title":"http和https的区别","slug":"http和https的区别","link":"#http和https的区别","children":[]},{"level":2,"title":"https通信过程","slug":"https通信过程","link":"#https通信过程","children":[]},{"level":2,"title":"数字证书的作用","slug":"数字证书的作用","link":"#数字证书的作用","children":[]},{"level":2,"title":"TLS/SSl（安全传输层协议（Transport Layer Security））工作原理","slug":"tls-ssl-安全传输层协议-transport-layer-security-工作原理","link":"#tls-ssl-安全传输层协议-transport-layer-security-工作原理","children":[]}],"relativePath":"计算机网络/https.md"}'),h={name:"计算机网络/https.md"},s=a('<h1 id="https知识总结" tabindex="-1">https知识总结 <a class="header-anchor" href="#https知识总结" aria-hidden="true">#</a></h1><h2 id="http和https的区别" tabindex="-1">http和https的区别 <a class="header-anchor" href="#http和https的区别" aria-hidden="true">#</a></h2><ul><li>http是超文本传输协议，信息是明文传输的，</li><li>http端口是80，https端口是443</li><li>https需要ca证书，费用较高</li><li>https是 tls/ssl+http</li></ul><h2 id="https通信过程" tabindex="-1">https通信过程 <a class="header-anchor" href="#https通信过程" aria-hidden="true">#</a></h2><p><img src="'+e+'" alt=""></p><h2 id="数字证书的作用" tabindex="-1">数字证书的作用 <a class="header-anchor" href="#数字证书的作用" aria-hidden="true">#</a></h2><ul><li>上图中，如果有一个中间人截取了服务器发送的公钥，然后将中间人的公钥发送给我们，他就可以使用私钥来解密我们发送的信息，这样他就可以窃取我们的消息了。</li><li>这时候就要使用数字证书了 <ol><li>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要。</li><li>然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成数字签名（防止中间人篡改证书）。</li><li>最后将原始的信息和签名合在一起，称为数字证书。</li><li>当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</li></ol></li><li>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全</li></ul><h2 id="tls-ssl-安全传输层协议-transport-layer-security-工作原理" tabindex="-1">TLS/SSl（安全传输层协议（Transport Layer Security））工作原理 <a class="header-anchor" href="#tls-ssl-安全传输层协议-transport-layer-security-工作原理" aria-hidden="true">#</a></h2><p>TLS/SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密。这三类算法的作用如下：</p><ol><li>基于散列函数验证信息的完整性</li><li>对称加密算法采用协商的秘钥对数据加密</li><li>非对称加密实现身份认证和秘钥协商</li></ol><h5 id="散列函数hash" tabindex="-1">散列函数hash <a class="header-anchor" href="#散列函数hash" aria-hidden="true">#</a></h5><ul><li>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</li><li>特点： 在信息传输过程中，散列函数不能都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</li></ul><h5 id="对称加密" tabindex="-1">对称加密 <a class="header-anchor" href="#对称加密" aria-hidden="true">#</a></h5><ul><li>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。</li><li>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</li><li>特点： 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</li></ul><h5 id="非对称加密" tabindex="-1">非对称加密 <a class="header-anchor" href="#非对称加密" aria-hidden="true">#</a></h5><ul><li>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</li><li>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</li><li>特点： 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。 综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</li></ul>',16),r=[s];function d(n,p,c,o,u,_){return i(),l("div",null,r)}const y=t(h,[["render",d]]);export{f as __pageData,y as default};
