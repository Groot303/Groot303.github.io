import{_ as l,c as i,o as e,d}from"./app.cec77ba5.js";const k=JSON.parse('{"title":"diff 算法","description":"","frontmatter":{},"headers":[{"level":3,"title":"简单diff算法","slug":"简单diff算法","link":"#简单diff算法","children":[]},{"level":3,"title":"双端diff算法","slug":"双端diff算法","link":"#双端diff算法","children":[]},{"level":3,"title":"快速diff算法","slug":"快速diff算法","link":"#快速diff算法","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"relativePath":"Vue原理/diff算法.md"}'),o={name:"Vue原理/diff算法.md"},f=d('<h1 id="diff-算法" tabindex="-1">diff 算法 <a class="header-anchor" href="#diff-算法" aria-hidden="true">#</a></h1><ul><li><p>在新旧 vnode 节点比较时，为了以最小的性能开销完成更新操作就需要用到diff算法</p></li><li><p>vue2中使用的是双端diff算法</p></li><li><p>vue3中使用的是快速diff算法</p></li></ul><h3 id="简单diff算法" tabindex="-1">简单diff算法 <a class="header-anchor" href="#简单diff算法" aria-hidden="true">#</a></h3><blockquote><p>一、找可复用的DOM</p></blockquote><ul><li>新旧虚拟节点对比时，如果两个虚拟节点的 type 属性和 key 属性值都相等的话，那就认为他们是相同的，可以进行 Dom 的复用；</li></ul><blockquote><p>二、打补丁（更新节点内容，利用patch）</p></blockquote><ul><li>但是需要注意的是：DOM可以复用并不代表节点不需要更新，因为有可能子节点的文本内容不一样，所以需要对新旧虚拟节点进行打补丁。</li></ul><blockquote><p>三、找需要移动的节点</p></blockquote><ul><li><p>取新的一组节点的第一个节点的key，去旧节点中寻找相同的key，如果能找到，并且索引值递增的顺序被打破，那这个节点对应的真实DOM就要移动</p></li><li><p>举个例子：</p><ul><li>旧节点： p-1 p-2 p-3 索引： 0 1 2</li><li>新节点： p-3 p-1 p-2 索引： 1 2 0</li></ul></li><li><p>可以看到索引值的递增顺序被打破了。所以 p-1 和 p-2 节点对应的真实DOM都要移动到 p-3 的后面</p></li></ul><h3 id="双端diff算法" tabindex="-1">双端diff算法 <a class="header-anchor" href="#双端diff算法" aria-hidden="true">#</a></h3><ul><li>因为简单的diff有缺陷，比如以上的例子中，需要移动两次DOM节点，而双端只需要移动一次就行，所以说双端diff做了减少dom的移动次数的优化</li></ul><blockquote><p>找可复用的DOM</p></blockquote><ul><li>定义四个索引，新旧两组节点的<code>开始索引</code>，<code>结束索引</code></li><li>步骤： <ul><li>新开始和旧开始比较，key相同就复用，否则什么都不做</li><li>新结尾和旧结尾比较，key相同就复用，否则什么都不做</li><li>新结尾和旧开始比较，key相同就复用，否则什么都不做</li><li>新开始和旧结尾比较，key相同就复用，否则什么都不做</li></ul></li></ul><blockquote><p>更新内容（打补丁），移动元素</p></blockquote><ul><li><p>可复用的节点找到之后需要调用patch函数进行打补丁，然后移动元素</p></li><li><p>新旧节点的索引都是从两边向中间靠拢，当头部索引大于尾部索引就完成了更新</p></li></ul><blockquote><p>挂载新节点和卸载旧节点</p></blockquote><ul><li>如果找不到可复用的节点，那就会进行挂载新增节点和卸载旧节点的操作</li></ul><blockquote><p>非理想状态</p></blockquote><ul><li>当头尾节点都找不到复用的情况下，就会拿新节点的头部节点去旧节点中寻找，找到就复用</li></ul><h3 id="快速diff算法" tabindex="-1">快速diff算法 <a class="header-anchor" href="#快速diff算法" aria-hidden="true">#</a></h3><blockquote><p>预处理</p></blockquote><ul><li>先<code>从前往后</code>遍历找到全部相同的<code>前置节点</code></li><li>然后<code>从后往前</code>找到全部相同的<code>后置节点</code></li></ul><blockquote><p>找最长递增子序列</p></blockquote><ul><li>用一个source数组保存新节点在旧节点中的位置</li><li>求出source数组的最长递增子序列</li><li>最长递增子序列所对应的节点就是不需要移动的节点</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><ul><li><p>三种diff算法都遵循同样的处理规则：</p><ul><li>找到可复用的节点，打补丁，以及找到节点移动的位置</li><li>找出那些需要被添加删除节点</li></ul></li><li><p>只不过是在这些寻找的过程做了不同的优化而已</p></li></ul>',26),t=[f];function u(c,a,p,r,n,h){return e(),i("div",null,t)}const _=l(o,[["render",u]]);export{k as __pageData,_ as default};
