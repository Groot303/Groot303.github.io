import{_ as e,c as a,o as l,d as t}from"./app.f1dc7af0.js";const v=JSON.parse('{"title":"react 和 vue 的区别","description":"","frontmatter":{},"headers":[{"level":3,"title":"代码编写层面","slug":"代码编写层面","link":"#代码编写层面","children":[]},{"level":3,"title":"状态管理层面","slug":"状态管理层面","link":"#状态管理层面","children":[]},{"level":3,"title":"响应式原理层面","slug":"响应式原理层面","link":"#响应式原理层面","children":[]},{"level":3,"title":"框架整体设计层面","slug":"框架整体设计层面","link":"#框架整体设计层面","children":[]}],"relativePath":"React/react和vue的区别.md"}'),i={name:"React/react和vue的区别.md"},r=t('<h1 id="react-和-vue-的区别" tabindex="-1">react 和 vue 的区别 <a class="header-anchor" href="#react-和-vue-的区别" aria-hidden="true">#</a></h1><h3 id="代码编写层面" tabindex="-1">代码编写层面 <a class="header-anchor" href="#代码编写层面" aria-hidden="true">#</a></h3><ul><li>react 使用的 jsx 语法，</li><li>vue 更接近传统的 html、css 和 js 写法</li></ul><h3 id="状态管理层面" tabindex="-1">状态管理层面 <a class="header-anchor" href="#状态管理层面" aria-hidden="true">#</a></h3><ul><li><p>react 没有内置的状态管理解决方案，需要和外部库结合使用，如Redux、Mobx</p></li><li><p>vue 内置了 vuex</p></li></ul><h3 id="响应式原理层面" tabindex="-1">响应式原理层面 <a class="header-anchor" href="#响应式原理层面" aria-hidden="true">#</a></h3><ul><li><p>vue 基于 mvvm 的<code>数据双向绑定</code>，自动进行依赖收集和自动重新渲染；</p></li><li><p>react 是<code>单向数据流</code>，利用 setState 驱动新的 state 替换老的 state， 数据改变时，以组件为根目录，默认全部重新渲染。</p></li></ul><h3 id="框架整体设计层面" tabindex="-1">框架整体设计层面 <a class="header-anchor" href="#框架整体设计层面" aria-hidden="true">#</a></h3><h4 id="编译时机" tabindex="-1">编译时机 <a class="header-anchor" href="#编译时机" aria-hidden="true">#</a></h4><ul><li><p>vue 是编译+运行时的框架</p><ul><li>因为 vue 使用的是模板语法描述页面，所以它可以在编译后形成的虚拟dom上进行一些操作，给可变的内容做标记，这样就可以提高在运行对比新旧dom的函数的性能</li></ul></li><li><p>react 是运行时的框架</p><ul><li>因为 react 使用的是 jsx 来描述页面，jsx 是 js 的语法糖，而js 的语法比较灵活，很难进行静态分析，所以说 react 是一个偏运行时的框架</li></ul></li></ul><h4 id="框架分类" tabindex="-1">框架分类 <a class="header-anchor" href="#框架分类" aria-hidden="true">#</a></h4><ul><li><p>vue 是组件级的框架</p><ul><li>基于数据双向绑定的原理，变量的改变触发的是组件的更新，它能自动追踪依赖</li></ul></li><li><p>react 是应用级的框架</p><ul><li><p>变量的改变会触发更新流程：从根节点开始，遍历整个应用；所以基于这样的实现原理。react不需要确定是哪个变量变化了。因此react不需要“细粒度更新”</p></li><li><p>每次更新都遍历应用，性能不会很差，因为react内部有优化机制，而且提供了api让开发者使用，减少无意义的遍历过程，如：shouldComponentUpdate、React.memo、PureComponent</p></li></ul></li></ul>',12),c=[r];function d(h,n,s,u,o,p){return l(),a("div",null,c)}const m=e(i,[["render",d]]);export{v as __pageData,m as default};
