import{_ as t,c as e,a as l,b as o,t as n,d as r,o as s}from"./app.eb5477ea.js";const j=JSON.parse('{"title":"js的数据类型相关问题","description":"","frontmatter":{"title":"js的数据类型相关问题","categories":["JavaScript"],"tags":["js基础"],"sidebar":"auto"},"headers":[],"relativePath":"html&css&js/JavaScript/js的数据类型相关问题.md"}'),a={name:"html&css&js/JavaScript/js的数据类型相关问题.md"},u={id:"frontmatter-title",tabindex:"-1"},p=l("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),c=r('<p>💥 <strong>js的数据类型和区别</strong></p><ul><li>基本类型：number、string、boolean、symbol 、null、undefined 6种、</li><li>引用类型：object、array、function 3种</li><li>基本类型在栈中存储，引用类型的数据在堆中存储，栈中存储的是引用地址</li></ul><p>💥 <strong>== 类型转化的规则</strong></p><ul><li>string -&gt; number</li><li>boolean 与其他类型比较 boolean -&gt; number</li><li>object -&gt; 原始类型</li><li>引用类型与值类型比较，引用类型先转换成值类型</li><li>null == undefined</li><li>null, undefined, NaN 与其他类型都返回 false</li></ul><p>💥 <strong><a href="http://Object.is" target="_blank" rel="noreferrer">Object.is</a>( ) 和 === 、 == 的区别</strong></p><ul><li>== 等会先进行类型转换，再进行值的比较，</li><li>=== 全等不会做类型转换，必须值和类型都相等</li><li><a href="http://object.is" target="_blank" rel="noreferrer">object.is</a> () 和 === 行为基本一致，除了 +0、-0 不相等，NaN 相等</li></ul><p>💥 <strong>null 和 undefined</strong></p><ul><li>null 表示“没有对象”，该处不应该有值，使用 typeof 检验返回 Object 可以看成一个空对象指针</li><li>undefined 表示“缺少值”，但是还没定义</li><li>转为数值时，值不一样，undefined转为数值NaN，null转为数值0</li></ul><p>💥 <strong>检测数据类型的方法和局限性</strong></p><ul><li>typeof <ul><li>只能检测基本数据类型，无法准确判断引用数据类型（都是返回Object）</li></ul></li><li>instanceof <ul><li>用来判断引用类型，判断一个对象是否存在于构造函数的prototype属性上</li><li>如果是基本数据类型要用 new 关键字创建一个基本数据类型才能判断</li><li>无法检测 null 和 undefined</li><li>原型链可以手动修改，检测不准确</li></ul></li><li>constructor <ul><li>构造函数的prototype属性中有constructor这个属性指向构造函数本身</li><li>无法检测 null 和 undefined</li><li>更改构造函数的 prototype 属性，造成检测不准确</li></ul></li><li>Object.prototype.toString.call（） <ul><li>基本没有缺陷</li></ul></li></ul><p>💥 <strong>为什么0.1 + 0.2 ！== 0.3，如何让其相等</strong></p><ul><li>js的number类型使用64位固定长度表示，0.1和0.2的二进制都是无限循环数相加之后转成十进制截断就不是0.3了</li><li>使用Math.toFixed()，保留你需要的小数点位数。</li></ul><p>💥 <strong>object和map的区别</strong></p><ol><li>key值不同。object只能是简单的数据类型，map可以是所有数据类型</li><li>map元素顺序遵循插入顺序，object没有</li><li>增删数据的写法不同</li><li>获取数据长度。map.size()，object.keys()</li></ol><hr><p>💥 <strong>symbol的特性</strong></p><ol><li>表示独一无二的值，可以用来定义对象的唯一属性名</li><li>symbol值不能和其他类型的值进行计算</li><li>symbol可以转为字符串、布尔值，但是不能转成数值</li><li>Symbol.for()和Symbol.keyFor()方法</li></ol><p>○ Symbol.for()：全局搜索有没有该Symbol值，如果有则返回该Symbol值，否则新建并返回一个以该参数为名称的Symbol值。 ○ Symbol.keyFor()：检测有没有创建该symbol值</p><p>💥 <strong>isNaN 和 Number.isNaN 函数的区别</strong></p><ul><li>isNaN会将参数转换成数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true 会影响 NaN 的判断</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确</li></ul><p>💥 <strong>js 如何进行隐式类型转换</strong></p><ul><li>ToPrimitive方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。</li></ul><p>💥 <strong>什么是 js 中的包装类型</strong></p><ul><li>基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：可以访问string.length属性</li><li>也可以使用Object函数显式地将基本类型转换为包装类型：.</li><li>也可以使用valueOf方法将包装类型倒转成基本类型：</li></ul><p>💥 <strong>其他值转字符串、数字、布尔值的规则</strong></p><ul><li>转字符：直接转成字符串</li><li>转数值：Undefined -&gt; NaN，Null -&gt; 0 ，true -&gt; 1，false -&gt; 0，对象类型首先会被转换为相应的基本类型值，再按上述规则转成数字</li><li>转布尔值：假值 ：undefined、 null 、 false 、 +0、-0 、 NaN 、 &quot;&quot; -&gt; false</li></ul><hr><p>💥 <strong>object.assign 和 扩展运算符两者区别</strong></p><ul><li>两者都是浅拷贝</li><li>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</li><li>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</li></ul><p>💥 <strong>|| 和 &amp;&amp; 的返回值</strong></p><ul><li>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li><li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值</li><li>什么时候用于字符串的拼接</li><li>如果 + 的其中一个操作数是字符串（或者会转换成字符串），则执行字符串拼接，否则执行数字加法。</li><li>对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</li></ul><p>💥 <strong>如何获取安全的undefined值</strong></p><ul><li>undefined是一个标识符，可以被当作变量来使用和赋值，但是会影响undefined的正常判断</li><li>可以使用 viod 0 来获取 undefined</li></ul>',33);function d(i,g,b,f,m,_){return s(),e("div",null,[l("h1",u,[o(n(i.$frontmatter.title)+" ",1),p]),c])}const y=t(a,[["render",d]]);export{j as __pageData,y as default};
