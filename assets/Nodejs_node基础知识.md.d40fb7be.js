import{_ as e,c as a,o as l,d as s}from"./app.655126e9.js";const C=JSON.parse('{"title":"Node.js 基础知识","description":"","frontmatter":{},"headers":[{"level":2,"title":"常用工具模块","slug":"常用工具模块","link":"#常用工具模块","children":[]},{"level":2,"title":"文件操作","slug":"文件操作","link":"#文件操作","children":[]},{"level":2,"title":"文件夹操作","slug":"文件夹操作","link":"#文件夹操作","children":[]},{"level":2,"title":"常用的检测方法","slug":"常用的检测方法","link":"#常用的检测方法","children":[]},{"level":2,"title":"一些好用的第三方库","slug":"一些好用的第三方库","link":"#一些好用的第三方库","children":[]},{"level":2,"title":"一些高级的文件操作","slug":"一些高级的文件操作","link":"#一些高级的文件操作","children":[]},{"level":2,"title":"buffer和流","slug":"buffer和流","link":"#buffer和流","children":[]}],"relativePath":"Nodejs/node基础知识.md"}'),n={name:"Nodejs/node基础知识.md"},i=s(`<h1 id="node-js-基础知识" tabindex="-1">Node.js 基础知识 <a class="header-anchor" href="#node-js-基础知识" aria-hidden="true">#</a></h1><h2 id="常用工具模块" tabindex="-1">常用工具模块 <a class="header-anchor" href="#常用工具模块" aria-hidden="true">#</a></h2><h5 id="一、path-路径处理工具" tabindex="-1">一、path：路径处理工具 <a class="header-anchor" href="#一、path-路径处理工具" aria-hidden="true">#</a></h5><ul><li>basename: 路径最后一部分</li><li>dirname: 文件夹的绝对路径</li><li>parse：解析路径对象</li><li>format：对象解析为路径，与parse相对</li><li>resolve：把一个路径解析为绝对路径</li><li>join：路径拼接</li></ul><div class="language-node"><button title="Copy Code" class="copy"></button><span class="lang">node</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">const path = require(&quot;path&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">let demo = &quot;./src/a/b/c.js&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">let p = path.parse(demo)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(path.basename(demo));   // c.js</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(path.dirname(demo));    // ./src/a/b</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(path.parse(demo));      // { root: &#39;&#39;, dir: &#39;./src/a/b&#39;, base: &#39;c.js&#39;, ext: &#39;.js&#39;, name: &#39;c&#39; }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(path.format(p));        // ./src/a/b\\c.js</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(path.resolve(__dirname)); // __dirname是一个全局变量, D:\\zz\\Note\\webNote\\Node.js</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(path.resolve(&quot;../&quot;, &#39;.d.js&#39;));  // D:\\zz\\Note\\webNote\\.d.js</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(path.join(&quot;./a&quot;, &quot;./b&quot;));  // a/b</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h5 id="二、process-进程相关" tabindex="-1">二、process：进程相关 <a class="header-anchor" href="#二、process-进程相关" aria-hidden="true">#</a></h5><ul><li>argv：启动node时的命令行参数</li><li>execArgv：node命令后的直接参数</li><li>env：用户环境信息</li><li>cwd()：获取当前进程工作目录</li><li>exit(): 退出进程</li><li>stdout、stdin：屏幕输出和输入</li><li>memoryUsage()： 内存使用情况</li><li>监听：process 是一个可监听对象</li></ul><h5 id="三、util-工具函数" tabindex="-1">三、util: 工具函数 <a class="header-anchor" href="#三、util-工具函数" aria-hidden="true">#</a></h5><ul><li>promiseify：把异步回调函数包装为promise形式</li><li>callbackify：将一个返回值为promise的函数改成回调</li></ul><p>💥 node 所有异步操作都是通过回调获取结果的，比较容易形成回调地狱；几乎所有的回调第一个参数都是err，后面的才是结果。这也是 node 作者嫌弃的原因，后面写了deno</p><h2 id="文件操作" tabindex="-1">文件操作 <a class="header-anchor" href="#文件操作" aria-hidden="true">#</a></h2><h5 id="api" tabindex="-1">api <a class="header-anchor" href="#api" aria-hidden="true">#</a></h5><ul><li>readFile 读取 <ul><li>文件读取的方法全部是异步操作</li><li>文件操作的异步形式都会有一个回调，在最后一个参数</li><li>所有的方法都会有同步版本</li></ul></li><li>writeFile 写入</li><li>unlink 删除</li><li>appendFile 插入</li><li>rename 移动（重命名）</li><li>copyFile 拷贝</li></ul><div class="language-node"><button title="Copy Code" class="copy"></button><span class="lang">node</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const fs = require(&#39;fs&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">fs.writeFile(&quot;./test.txt&quot;, &quot;hello&quot;, function (err, res) { }) //异步版本</span></span>
<span class="line"><span style="color:#A6ACCD;">const res = fs.writeFileSync(&quot;./test2.txt&quot;, &quot;hello&quot;) // 同步版本</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="文件夹操作" tabindex="-1">文件夹操作 <a class="header-anchor" href="#文件夹操作" aria-hidden="true">#</a></h2><ul><li>readdir 读取</li><li>mkdir 创建</li><li>rmdir 删除</li><li>拷贝和移动：没有直接api 只能遍历</li></ul><h2 id="常用的检测方法" tabindex="-1">常用的检测方法 <a class="header-anchor" href="#常用的检测方法" aria-hidden="true">#</a></h2><ul><li>exits 是否存在</li><li>stat 获取文件的状态信息</li></ul><h2 id="一些好用的第三方库" tabindex="-1">一些好用的第三方库 <a class="header-anchor" href="#一些好用的第三方库" aria-hidden="true">#</a></h2><ul><li>fs-extra</li><li>compressing <ul><li>.zip.compressDir： 压缩</li><li>.zip.uncompress：解压</li></ul></li></ul><h2 id="一些高级的文件操作" tabindex="-1">一些高级的文件操作 <a class="header-anchor" href="#一些高级的文件操作" aria-hidden="true">#</a></h2><ul><li>watch 监听（webpack中监听文件改变重新打包）</li><li>open 自由操作</li><li>read、write 自由读取和写入</li><li>writeStream、readStream 流形式操作</li></ul><h2 id="buffer和流" tabindex="-1">buffer和流 <a class="header-anchor" href="#buffer和流" aria-hidden="true">#</a></h2><p>💥 buffer 可以理解为一个固定长度的字符串数组，存在于v8内存外，储存文件的二进制内容</p><h5 id="buffer相关操作" tabindex="-1">buffer相关操作 <a class="header-anchor" href="#buffer相关操作" aria-hidden="true">#</a></h5><ol><li>创建</li></ol><div class="language-node"><button title="Copy Code" class="copy"></button><span class="lang">node</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">const bf1 = Buffer.alloc(10, &#39;1&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">const bf2 = Buffer.from(&quot;hello&quot;) </span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(bf1.toString());//1111111111</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>💥 流可以理解成一个管道</p><p>当一个文件很大的时候，如果用buffer一次性读取会造成系统卡顿，所以可以使用流进行读取</p>`,29),o=[i];function t(r,p,c,d,h,u){return l(),a("div",null,o)}const A=e(n,[["render",t]]);export{C as __pageData,A as default};
