import{_ as l,c as e,o as s,d as a}from"./app.21f93f85.js";const F=JSON.parse('{"title":"html5知识总结","description":"","frontmatter":{},"headers":[{"level":2,"title":"一些HTML5的新标签。","slug":"一些html5的新标签。","link":"#一些html5的新标签。","children":[]},{"level":2,"title":"HTML5的一些新特性。","slug":"html5的一些新特性。","link":"#html5的一些新特性。","children":[]},{"level":2,"title":"HTML5增强表单中新的输入类型属性","slug":"html5增强表单中新的输入类型属性","link":"#html5增强表单中新的输入类型属性","children":[]},{"level":2,"title":"cookie、localstroage、sessionStorage的区别？优缺点？","slug":"cookie、localstroage、sessionstorage的区别-优缺点","link":"#cookie、localstroage、sessionstorage的区别-优缺点","children":[]},{"level":2,"title":"html标签中的src和href的区别？","slug":"html标签中的src和href的区别","link":"#html标签中的src和href的区别","children":[]},{"level":2,"title":"html页面渲染过程","slug":"html页面渲染过程","link":"#html页面渲染过程","children":[]},{"level":2,"title":"script标签中defer和async的区别","slug":"script标签中defer和async的区别","link":"#script标签中defer和async的区别","children":[]}],"relativePath":"html&css&js/html/html5.md"}'),o={name:"html&css&js/html/html5.md"},t=a(`<h1 id="html5知识总结" tabindex="-1">html5知识总结 <a class="header-anchor" href="#html5知识总结" aria-hidden="true">#</a></h1><h2 id="一些html5的新标签。" tabindex="-1">一些HTML5的新标签。 <a class="header-anchor" href="#一些html5的新标签。" aria-hidden="true">#</a></h2><ol><li><code>&lt;article&gt;</code>用来定义独立的内容</li><li><code>&lt;audio&gt;</code>用来定义声音内容</li><li><code>&lt;canvas&gt;</code>用来定义图形</li><li><code>&lt;header&gt;</code>用来定义页眉</li><li><code>&lt;footer&gt;</code>用来定义页脚</li><li><code>&lt;nav&gt;</code>用来定义导航链接</li><li><code>&lt;video&gt;</code>用来定义视频</li></ol><h2 id="html5的一些新特性。" tabindex="-1">HTML5的一些新特性。 <a class="header-anchor" href="#html5的一些新特性。" aria-hidden="true">#</a></h2><ol><li>canvas：HTML5的一个新元素，它使用JavaScript在网页上绘制图形。</li><li>video和audio：用于视频和音频的播放。</li><li>本地离线存储：localStorage长期存储数据，<code>浏览器关闭后数据不丢失</code>。sessionStorage的数据在<code>浏览器关闭后自动删除</code>。</li><li>新的结构标签：语义化更好的内容元素，比如article，footer，header，nav，section。</li><li>增强表单：input的type属性值新增calendar,date,time,email,url等。</li><li>新的技术webworker，websockt，Geolocation</li></ol><h2 id="html5增强表单中新的输入类型属性" tabindex="-1">HTML5增强表单中新的输入类型属性 <a class="header-anchor" href="#html5增强表单中新的输入类型属性" aria-hidden="true">#</a></h2><ol><li>search：用于搜索域，比如站点搜索或Google搜索，域显示为常规的文本域。</li><li>url：用于应该包含URL地址的输入域在提交表单时，会自动验证url域的值。</li><li>email：用于应该包含e-mail地址的输入域，在提交表单时，会自动验证email域的值。</li><li>datetime：选取时间、日、月、年（UTC时间）。date：选取日、月、年month：选取月、年。week：选取周和年。</li><li>time：选取时间（小时和分钟）。</li><li>datetime-local：选取时间、日、月、年（本地时间）。</li><li>number：用于应该包含数值的输入域，您还能够设定对所接受的数字的限定。</li><li>range：用于应该包含一定范围内数字值的输入域，类型显示为滑动条。</li></ol><h2 id="cookie、localstroage、sessionstorage的区别-优缺点" tabindex="-1">cookie、localstroage、sessionStorage的区别？优缺点？ <a class="header-anchor" href="#cookie、localstroage、sessionstorage的区别-优缺点" aria-hidden="true">#</a></h2><h5 id="cookie" tabindex="-1">cookie： <a class="header-anchor" href="#cookie" aria-hidden="true">#</a></h5><ul><li>是服务器发给客户端的特殊信息，以文本形式存储在客户端，每次请求都会带上cookie。</li><li>保存时间：设置过期时间，浏览器关闭后不会清除，保存在硬盘中,过期时间到期后失效。如果不设置过期时间，保存在内存中,浏览器关闭后消失。</li><li>缺点：</li></ul><ol><li>大小受限，单个cookie大小不能超过4kb</li><li>用户可以禁用cookie,使功能受限。</li><li>安全性较低，有些状态不能保存在客户端。</li><li>每次访问都要传送cookie给服务器，浪费带宽。</li><li>cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。</li></ol><h5 id="localstorage和sessionstorage" tabindex="-1">localStorage和sessionStorage: <a class="header-anchor" href="#localstorage和sessionstorage" aria-hidden="true">#</a></h5><ul><li>存储大小都是5MB，都保存在客户端不与服务器端进行交互，只能储存字符串类型，对于复杂的json格式可以进行stringify和parse来处理。</li><li>区别是localStorage是永久储存,除非主动删除,否则不会消失；而sessionStroage的有效期只是网页在浏览器打开到关闭的时间段。</li></ul><h2 id="html标签中的src和href的区别" tabindex="-1">html标签中的src和href的区别？ <a class="header-anchor" href="#html标签中的src和href的区别" aria-hidden="true">#</a></h2><ul><li>href是超文本引用，它是指向资源的位置，建立与目标文件的联系</li><li>src目的是把资源下载到页面中浏览器解析</li><li>href不会阻塞对文档的处理（这就是官方建议使用link引入而不是@import的原因），src会阻塞对文档的处理。</li></ul><h2 id="html页面渲染过程" tabindex="-1">html页面渲染过程 <a class="header-anchor" href="#html页面渲染过程" aria-hidden="true">#</a></h2><ol><li>解析html文件，创建dom树</li><li>解析css，形成css对象模型</li><li>将css与DOM合并，构建渲染树</li><li>布局和绘制重绘： 重绘：是改变不影响元素的网页中的位置的元素样式（重绘不会带来重新布局，所以并不一定伴随重排） 重排：渲染绘制，即根据计算好的信息绘制整个页面，渲染出最终的页面。重绘不一定需要重排，重排必然导致重绘</li></ol><h2 id="script标签中defer和async的区别" tabindex="-1">script标签中defer和async的区别 <a class="header-anchor" href="#script标签中defer和async的区别" aria-hidden="true">#</a></h2><h5 id="defer" tabindex="-1">defer： <a class="header-anchor" href="#defer" aria-hidden="true">#</a></h5><ol><li>浏览器指示脚本在文档被解析后执行，script被异步加载后并不会立即执行，而是等待文档被解析完毕后执行</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">text/javascript</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">x.min.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">defer</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">defer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><ol start="2"><li><code>defer只适用于外联脚本</code>，如果script标签没有指定src属性，只是内联脚本，不要使用defer</li><li>如果有多个声明了defer的脚本，则会按顺序下载和执行</li><li>defer脚本会在DOMContentLoaded和load事件之前执行</li></ol><h5 id="async" tabindex="-1">async <a class="header-anchor" href="#async" aria-hidden="true">#</a></h5><ol><li>同样是异步加载脚本，区别是脚本加载完毕后立即执行，这导致async属性下的脚本是乱序的，对于script又先后依赖关系的情况，并不适用</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">text/javascript</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">x.min.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">async</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">async</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><ol start="2"><li><code>只适用于外联脚本</code>，这一点和defer一致如果有多个声明了async的脚本，其下载和执行也是异步的，不能确保彼此的先后顺序</li><li>async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序</li></ol>`,26),i=[t];function n(r,c,d,p,h,D){return s(),e("div",null,i)}const m=l(o,[["render",n]]);export{F as __pageData,m as default};
