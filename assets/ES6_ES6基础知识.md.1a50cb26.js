import{_ as t,c as e,a as l,b as o,t as r,d as s,o as a}from"./app.eb5477ea.js";const E=JSON.parse('{"title":"ES6基础知识汇总","description":"","frontmatter":{"title":"ES6基础知识汇总","categories":["ES6"],"tags":["ES6基础"]},"headers":[],"relativePath":"ES6/ES6基础知识.md"}'),n={name:"ES6/ES6基础知识.md"},p={id:"frontmatter-title",tabindex:"-1"},u=l("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),c=s("<p>💥 <strong>var、let、const</strong></p><ul><li>var存在变量提升</li><li>let和const具有块级作用域，var不存在块级作用域</li><li>let和const 存在暂时性死区，即在声明变量之前不能使用、不能重复声明</li><li>var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</li></ul><p>💥 <strong>set</strong></p><ol><li>键和值相同</li><li>增删改查的操作方法：add、delete、has、clear</li><li>遍历方法： <ul><li>for of + keys返回键名，values返回键值，entries返回键值对、</li><li>for of</li><li>forEach( )参数是一个处理函数</li><li>扩展运算符（ ...）（内部使用的是 for of）</li></ul></li></ol><p>💥 <strong>map</strong></p><ol><li>键-值形式，键可以是各种类型、</li><li>一些操作方法：set(key, value)、get(key)、has(key)、delete(key)、clear()：清楚所有成员</li><li>遍历方法：和 set 一样</li><li>转换成数组：Array.for()、扩展运算符（...）</li></ol><p>💥 <strong>箭头函数和普通函数的区别</strong></p><ul><li>没有arguments。可以利用rest参数模拟</li><li>没有自己的this值，箭头函数的this是上层函数作用域的this对象(一层层向上找)普通函数的this指向该函数的调用者。</li><li>call, apply, bind会改变普通函数的this，但箭头函数不能使用这三个方法来改变环境上下文</li><li>箭头函数不能使用new生成实例，因为它没有 prototype 和自己的 this 对象</li><li>箭头函数内不能用yield且不能用作Generator函数，而普通函数可以</li></ul><hr><p>💥 <strong>WeakSet、WeakMap</strong></p><ul><li><p>成员只能是对象</p></li><li><p>无法遍历、无法清空</p></li><li><p>弱引用（通俗来说就是没有引用和该键引用同一个对象时，对象就会被回收，相应的key变成无效，也是无法遍历的原因）</p></li><li><p>应用场景：储存dom元素（键名是dom节点，当删除节点时，键就消失了）、存储私有变量</p></li></ul><p>💥 <strong>对rest参数的理解</strong></p><ul><li>箭头函数的 arguments 可以用 ...rest 参数模拟</li></ul><p>💥 <strong>模板语法和字符串处理</strong></p><ul><li>模板语法让拼接字符串变得方便</li><li>includes：判断字符串与子串的包含关系</li><li>startsWith：判断字符串是否以某个/某串字符开头</li><li>endsWith：判断字符串是否以某个/某串字符结</li><li>repeat(重复的次数)：使同一个字符串输出多次（被连续复制多次）</li></ul><p>💥 <strong>commonJS和ES6 Module的区别</strong></p><p>1️⃣ <strong>CommonJS</strong></p><ul><li>模块输出的是一个值的拷贝（模块内部值的变化影响不到这个值了）</li><li>require 语法是同步的，必须等模块加载完后，才会执行后面的代码，主要针对服务端，使用require只需要在本地硬盘中读取文件，速度较快</li><li>Common JS加载的是一个对象，这个对象只有在脚本运行时才会生成，而且只会生成一次</li></ul><p>2️⃣ <strong>ES6 Module</strong></p><ul><li>输出的是值的引用，原始值变了，import加载的值也会跟着变</li><li>ES6 Module 不是对象，它对外的接口只是一种静态定义，在代码解析阶段就会生成，这样就可以使用各种工具对js模块进行静态分析，优化代码，Webpack中的 tree shaking 和 scope hoisting 实际上就是依赖ES6模块化。</li></ul><p>💥 <strong>ES6 module和common js循环加载的区别</strong></p><p>在大型项目中，循环加载相互依赖的情况很难避免的</p><ul><li><p>common js的循环加载</p><ul><li>脚本代码在 require 的时候就会全部执行，一旦出现某个模块被&quot;循环加载&quot;，就只输出已经执行的部分，还未执行的部分不会输出。</li></ul></li><li><p>es6 Module的循环加载</p><ul><li>ES6模块是动态引用，如果使用import从一个模块加载变量（即import foo from &#39;foo&#39;），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</li></ul><hr></li></ul><p>💥 <strong>扩展运算符作用和使用场景</strong></p><ul><li>对象、数组等的扩展</li><li>合并数组、将字符串转成真正的数组</li><li>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</li><li>用在函数形参上时，还可以把一个分离的参数序列整合成一个数组</li></ul>",25);function d(i,g,_,m,h,S){return a(),e("div",null,[l("h1",p,[o(r(i.$frontmatter.title)+" ",1),u]),c])}const k=t(n,[["render",d]]);export{E as __pageData,k as default};
