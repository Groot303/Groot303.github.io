import{_ as i,c as t,a as e,b as l,t as r,d,o as n}from"./app.7814b68a.js";const g=JSON.parse('{"title":"vue3和vue2的区别","description":"","frontmatter":{"title":"vue3和vue2的区别","date":"2022-11-22","categories":["Vue3"],"tags":["vue3"]},"headers":[{"level":2,"title":"原理方面","slug":"原理方面","link":"#原理方面","children":[]},{"level":2,"title":"性能优化","slug":"性能优化","link":"#性能优化","children":[]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[]},{"level":2,"title":"组合式api","slug":"组合式api","link":"#组合式api","children":[]},{"level":2,"title":"速度更快","slug":"速度更快","link":"#速度更快","children":[]}],"relativePath":"Vue基础/vue3和vue2的区别.md"}'),h={name:"Vue基础/vue3和vue2的区别.md"},s={id:"frontmatter-title",tabindex:"-1"},u=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),o=d('<h2 id="原理方面" tabindex="-1">原理方面 <a class="header-anchor" href="#原理方面" aria-hidden="true">#</a></h2><ul><li>响应式原理利用 proxy <ul><li>vue3并不是完全抛弃了defineProperty,通过reactive.定义的响应式数据使用proxy包装出来，而ref还是用的defineProperty去给一个空对象，定义了一个value属性来做的响应式</li></ul></li></ul><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-hidden="true">#</a></h2><ul><li>vue3利用函数式编程可以按需引入充分配合tree-shaking，让打包体积更小</li><li>静态节点标记</li><li>推荐hook <ul><li>易于理解和维护（允许你根据功能来组织代码，而不是根据选项），</li><li>更好的代码重用、避免命名冲突：你可以将相关逻辑封装到自定义函数中，然后在组件中按需使用，而不需要关心命名冲突或组件之间的耦合问题</li></ul></li></ul><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-hidden="true">#</a></h2><ul><li>没有 beforeCreated 和 create</li></ul><h2 id="组合式api" tabindex="-1">组合式api <a class="header-anchor" href="#组合式api" aria-hidden="true">#</a></h2><ul><li>相同的业务逻辑可以写在一起</li></ul><h2 id="速度更快" tabindex="-1">速度更快 <a class="header-anchor" href="#速度更快" aria-hidden="true">#</a></h2><ul><li>配合 vite</li></ul>',10);function c(a,_,v,p,f,m){return n(),t("div",null,[e("h1",s,[l(r(a.$frontmatter.title)+" ",1),u]),o])}const k=i(h,[["render",c]]);export{g as __pageData,k as default};
